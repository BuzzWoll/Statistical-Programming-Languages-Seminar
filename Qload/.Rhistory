C = scale(A,scale=F)
V = cov(C)
Eig = eigen(V)
values = Eig$values
vectors = Eig$vectors
P = C %*% vectors
print(P)
print(vectors)
print(prcomp(A,center = T,scale. = F))
M = colMeans(A)
A
M
C = A-M
C
print(A)
print(M)
print(C)
C = t(A)-M
C
C = t(t(A)-M)
C
print(A)
print(M)
print(C)
V = cov(x.sample)
library("xts")
load("../Qprepare/prepareddataSC.RData")
# first row of train only contains zeros!
#train = unscaled_train
train = scaledtrain
# Format data into POSIXct
train[,1] = as.POSIXct(train[,1])
dates = train[,1]
# probably unnecessary!!!
end_date = as.POSIXct("2015-01-01 01:00:00 CET")
last_known_data = which(dates == end_date)-1
origin = "1970-01-01 00:00:00"
x_raw = xts(train[,-1], order.by = train[,1])
# Only use data until december 2014 to select the model
x.sample = x_raw['/2014-12-01']
y.sample = (x.sample$`S&P500`)
V = cov(x.sample)
Eig = eigen(V)
values = Eig$values
vectors = Eig$vectors
P = x.sample %*% vectors
print(P)
prcomp(A,center = T,scale. = F)
prcomp(A,center = T,scale. = F)$Rotation
a = prcomp(A,center = T,scale. = F)
a$rotation
vectors
print(prcomp(A,center = F,scale. = F)$rotation == vectors)
print(prcomp(A,center = F,scale. = F)$rotation == P)
print(prcomp(A,center = F,scale. = F)$rotation)
V = cov(C)
Eig = eigen(V)
values = Eig$values
vectors = Eig$vectors
P = C %*% vectors
print(P)
print(vectors)
print(prcomp(A,center = T,scale. = F))
a = prcomp(A,center = T,scale. = F)
a$rotation
print(prcomp(A,center = F,scale. = F)$rotation)
summary(prcomp(A,center = F,scale. = F))
prcomp(A,center = F,scale. = F)
head(vectors)
head(vectors)
prcomp(A,center = F,scale. = F)
V = cov(x.sample)
Eig = eigen(V)
values = Eig$values
vectors = Eig$vectors
P = x.sample %*% vectors
head(vectors)
prcomp(A,center = F,scale. = F)
V = cov(t(x.sample))
Eig = eigen(V)
values = Eig$values
vectors = Eig$vectors
P = x.sample %*% vectors
P =   vectors%*%x.sample
head(vectors)
vectors[,1:3]
vectors[1:3,1:3]
vectors[1:3,1:3]
prcomp(A,center = F,scale. = F)
P
prcomp(x.sample,center = F,scale. = F)
print(vectors)
print(head(vectors))
head(prcomp(x.sample,center = F,scale. = F)$rotations)
head(prcomp(x.sample,center = F,scale. = F)$rotation)
print(vectors[1:3,1:3])
head(prcomp(x.sample,center = F,scale. = F)$rotation)
A = matrix(c(4,-3,4,3),2)
#------------------------------------------------------------------
# We want to obtain:
# SVD = U*sigma*t(V)
#------------------------------------------------------------------
#------------------------------------------------------------------
# First we need to obtain the transpose of A
# t = Given a matrix or data.frame x, t returns the transpose of x.
#------------------------------------------------------------------
At= t(A)
#------------------------------------------------------------------
# Multiply the 2 matrices, At and A to obtain AtA
# %*% = Matrix Multiplication
#------------------------------------------------------------------
AtA=At%*%A
#------------------------------------------------------------------
# Now we need to obtain the spectral decomposition of the matrix AtA
# eigen = Computes eigenvalues and eigenvectors of real
#         (double, integer, logical) or complex matrices.
#------------------------------------------------------------------
eig1 = eigen(AtA)
#------------------------------------------------------------------
# With the eigenvalues of AtA we can build sigma.
# I did this manually here for the purpose of the procedure.
# However note that sigma is equal to sqrt(AAt)
#------------------------------------------------------------------
sigma=matrix(c(sqrt(eig1$values[1]),0,0,sqrt(eig1$values[2])),2)
#------------------------------------------------------------------
# The eigenvectors of AtA are the values of V
#------------------------------------------------------------------
V=as.matrix(eig1$vectors)
#------------------------------------------------------------------
# Next we need to compute A*At
#------------------------------------------------------------------
AAt=A%*%At
#------------------------------------------------------------------
# Now we need to obtain the spectral decomposition of the matrix AAt
#------------------------------------------------------------------
eig2=eigen(AAt)
#------------------------------------------------------------------
# U is equal to the eigen vectors of AAt
#------------------------------------------------------------------
U=as.matrix(eig2$vectors)
#------------------------------------------------------------------
# Finally the singular value decomposition of A is equal to U*sigma*V
#------------------------------------------------------------------
SVD_of_A=U%*%sigma%*%V
#------------------------------------------------------------------
# Results
#------------------------------------------------------------------
print(SVD_of_A)
print(prcomp(A,center = F,scale. = F))
a = prcomp(A,center = F,scale. = F)
A = matrix(c(4,-3,4,3),2)
A = matrix(c(4,-3,4,3),2)
#------------------------------------------------------------------
# We want to obtain:
# SVD = U*sigma*t(V)
#------------------------------------------------------------------
#------------------------------------------------------------------
# First we need to obtain the transpose of A
# t = Given a matrix or data.frame x, t returns the transpose of x.
#------------------------------------------------------------------
At= t(A)
#------------------------------------------------------------------
# Multiply the 2 matrices, At and A to obtain AtA
# %*% = Matrix Multiplication
#------------------------------------------------------------------
AtA=At%*%A
#------------------------------------------------------------------
# Now we need to obtain the spectral decomposition of the matrix AtA
# eigen = Computes eigenvalues and eigenvectors of real
#         (double, integer, logical) or complex matrices.
#------------------------------------------------------------------
eig1 = eigen(AtA)
#------------------------------------------------------------------
# With the eigenvalues of AtA we can build sigma.
# I did this manually here for the purpose of the procedure.
# However note that sigma is equal to sqrt(AAt)
#------------------------------------------------------------------
sigma=matrix(c(sqrt(eig1$values[1]),0,0,sqrt(eig1$values[2])),2)
#------------------------------------------------------------------
# The eigenvectors of AtA are the values of V
#------------------------------------------------------------------
V=as.matrix(eig1$vectors)
#------------------------------------------------------------------
# Next we need to compute A*At
#------------------------------------------------------------------
AAt=A%*%At
#------------------------------------------------------------------
# Now we need to obtain the spectral decomposition of the matrix AAt
#------------------------------------------------------------------
eig2=eigen(AAt)
#------------------------------------------------------------------
# U is equal to the eigen vectors of AAt
#------------------------------------------------------------------
U=as.matrix(eig2$vectors)
#------------------------------------------------------------------
# Finally the singular value decomposition of A is equal to U*sigma*V
#------------------------------------------------------------------
SVD_of_A=U%*%sigma%*%V
#------------------------------------------------------------------
# Results
#------------------------------------------------------------------
print(SVD_of_A)
print(prcomp(A,center = F,scale. = F))
a = prcomp(A,center = F,scale. = F)
print(U)
print(sigma)
print(V)
print(U)
print(sigma)
print(prcomp(A,center = F,scale. = F))
sigma2 = sqrt(AAt)
print(sigma)
print(sigma2)
print(sigma)
A = matrix(c(4,-3,4,3),2)
AtA=t(A)%*%A
AAt=A%*%t(A)
# Now we need to obtain the spectral decomposition of the matrix AtA
eig1 = eigen(AtA)
#Sigma is equal to sqrt(AAt)
sigma = sqrt(AAt)
# The eigenvectors of AtA are the values of V
V=as.matrix(eig1$vectors)
# Now we need to obtain the spectral decomposition of the matrix AAt
eig2=eigen(AAt)
# U is equal to the eigen vectors of AAt
U=as.matrix(eig2$vectors)
print(sigma)
print(V)
print(prcomp(A,center = F,scale. = F))
a = prcomp(A,center = F,scale. = F)
A = matrix(c(4,-3,4,3),2)
AtA=t(A)%*%A
AAt=A%*%t(A)
# Now we need to obtain the spectral decomposition of the matrix AtA
eig1 = eigen(AtA)
#Sigma is equal to sqrt(AAt)
sigma = sqrt(AAt)
# The eigenvectors of AtA are the values of V
V=as.matrix(eig1$vectors)
# Now we need to obtain the spectral decomposition of the matrix AAt
eig2=eigen(AAt)
# U is equal to the eigen vectors of AAt
U=as.matrix(eig2$vectors)
print(sigma)
print(V)
print(prcomp(A,center = F,scale. = F))
a = prcomp(A,center = F,scale. = F)
A = matrix(c(4,-3,4,3),2)
AtA=t(A)%*%A
AAt=A%*%t(A)
# Now we need to obtain the spectral decomposition of the matrix AtA
eig1 = eigen(AtA)
#Sigma is equal to sqrt(AAt)
sigma = sqrt(AAt)
# The eigenvectors of AtA are the values of V
V=as.matrix(eig1$vectors)
# Now we need to obtain the spectral decomposition of the matrix AAt
eig2=eigen(AAt)
# U is equal to the eigen vectors of AAt
U=as.matrix(eig2$vectors)
print(sigma)
print(V)
print(prcomp(A,center = F,scale. = F))
a = prcomp(A,center = F,scale. = F)
A = matrix(c(4,-3,4,3),2)
AtA=t(A)%*%A
AAt=A%*%t(A)
# Now we need to obtain the spectral decomposition of the matrix AtA
eig1 = eigen(AtA)
#Sigma is equal to sqrt(AAt)
sigma = sqrt(AAt)
sigma=matrix(c(sqrt(eig1$values[1]),0,0,sqrt(eig1$values[2])),2)
# The eigenvectors of AtA are the values of V
V=as.matrix(eig1$vectors)
# Now we need to obtain the spectral decomposition of the matrix AAt
eig2=eigen(AAt)
# U is equal to the eigen vectors of AAt
U=as.matrix(eig2$vectors)
print(sigma)
print(V)
print(prcomp(A,center = F,scale. = F))
a = prcomp(A,center = F,scale. = F)
A = x.sample
AtA=t(A)%*%A
AAt=A%*%t(A)
# Now we need to obtain the spectral decomposition of the matrix AtA
eig1 = eigen(AtA)
#Sigma is equal to sqrt(AAt)
sigma = sqrt(AAt)
# The eigenvectors of AtA are the values of V
V=as.matrix(eig1$vectors)
# Now we need to obtain the spectral decomposition of the matrix AAt
eig2=eigen(AAt)
# U is equal to the eigen vectors of AAt
U=as.matrix(eig2$vectors)
print(sigma[1:3,1:3])
print(V[1:3,1:3])
print(prcomp(A,center = F,scale. = F))
print(V[1:3,1:3])
print(prcomp(A,center = F,scale. = F)$rotation[1:3,1:3]
print(prcomp(A,center = F,scale. = F)$Rotation[1:3,1:3])
print(prcomp(A,center = F,scale. = F)$rotation[1:3,1:3])
print(V[1:3,1:3])
print(prcomp(A,center = F,scale. = F)$rotation[1:3,1:3])
print(V[1:4,1:4])
print(prcomp(A,center = F,scale. = F)$rotation[1:4,1:4])
pc = prcomp(A,center = F,scale. = F)
print(sigma[1:4,1:4])
print(pc$sdev[1:4])
svd(A,nu=0)
sv = svd(A,nu=0)
sv$d
sv$v
head(AAt)
intersect(AtA,AAt)
intersect(AtA[1,],AAt[1,])
sigma = sqrt(AAt)
AAt
AtA
sigma = sqrt(max(AAt,0))
sigma
A = x.sample
AtA=t(A)%*%A
AAt=A%*%t(A)
# Now we need to obtain the spectral decomposition of the matrix AtA
eig1 = eigen(AtA)
#Sigma is equal to sqrt(AAt)
sigma = ifelse(is.nan(sqrt(AAt)),0,sqrt(AAt))
# The eigenvectors of AtA are the values of V
V=as.matrix(eig1$vectors)
# Now we need to obtain the spectral decomposition of the matrix AAt
eig2=eigen(AAt)
# U is equal to the eigen vectors of AAt
U=as.matrix(eig2$vectors)
pc = prcomp(A,center = F,scale. = F)
print(V[1:4,1:4])
print(pc$rotation[1:4,1:4])
print(sigma[1:4,1:4])
print(pc$sdev[1:4])
sigma = ifelse(is.nan(sqrt(AtA)),0,sqrt(AtA))
print(sigma[1:4,1:4])
print(pc$sdev[1:4])
pca_data = prcomp(x.sample,
center = F,
scale. = F)
plot(pca_data, type = "l")
diag(AAt)
sigma = sqrt(diag(AAt))
print(sigma[1:4])
print(pc$sdev[1:4])
sigma = sqrt(diag(AtA))
print(sigma[1:4])
print(pc$sdev[1:4])
A = x.sample
ATA=t(A)%*%A
eig1 = eigen(ATA)
V=as.matrix(eig1$vectors)
AAT=A%*%t(A)
eig2 = eigen(AAT)
U=as.matrix(eig2$vectors)
r = sqrt(eig1$values)
sigma = r*diag(length(r))
pc = prcomp(A,center = F,scale. = F)
print(V[1:4,1:4])
print(pc$rotation[1:4,1:4])
print(sigma[1:4])
print(pc$sdev[1:4])
eig1$values
U %*% sigma %*% t(V)
r
diag(length(r))
sigma = r*diag(length(r))
sigma
U %*% sigma %*% t(V)
dim(U)
dim(V)
dim(sigma)
r = sqrt(eig2$values)
sigma = r*diag(length(r))
sigma
print(pc$sdev[1:4])
sv = svd(A)
sv = svd(A,nv=0)
sv$d
r / sqrt(max(1, nrow(A) - 1))
print(pc$sdev[1:4])
r / sqrt(max(1, nrow(A) - 1))
pca_data
stdev = r / sqrt(max(1, nrow(A) - 1))
sigm
U %*% sigma %*% t(V)
stdev = r / sqrt(max(1, nrow(A) - 1))
U %*% stdev %*% t(V)
str(pca_data)
pca_data$x
A %*% V
pca = function(A){
ATA=t(A)%*%A
eig1 = eigen(ATA)
V=as.matrix(eig1$vectors)
AAT=A%*%t(A)
eig2 = eigen(AAT)
U=as.matrix(eig2$vectors)
r = sqrt(eig2$values)
sigma = r*diag(length(r))
stdev = r / sqrt(max(1, nrow(A) - 1))
x = A %*% V
}
pca = function(A){
ATA=t(A)%*%A
eig1 = eigen(ATA)
V=as.matrix(eig1$vectors)
AAT=A%*%t(A)
eig2 = eigen(AAT)
U=as.matrix(eig2$vectors)
r = sqrt(eig2$values)
sigma = r*diag(length(r))
stdev = r / sqrt(max(1, nrow(A) - 1))
x = A %*% V
res = list(sdev = stdev, rotation = V, x = x)
res
}
pca_data2 = pca(x.sample)
pca_data2
pca_data = pca(x.sample)
summary(pca_data)
plot(pca_data, type = "l")
screeplot.default(pca_data,main = deparse(substitute(pca_data)))
screeplot(pca_data,main = deparse(substitute(pca_data)))
pca_data2 = prcomp(x.sample, center = F,scale. = F)
pca_data2$x[,1:5]
pca_data$x[,1:5]
diff_index = xts(pca_data$x[,1:5], order.by = dates[1:273])
diff_index2 = xts(pca_data2$x[,1:5], order.by = dates[1:273])
diff_index
diff_index2
pca = function(A){
ATA=t(A)%*%A
eig1 = eigen(ATA)
V=as.matrix(eig1$vectors)
dimnames(V) = list(colnames(A),paste0("PC",seq_len(ncol(V))))
AAT=A%*%t(A)
eig2 = eigen(AAT)
U=as.matrix(eig2$vectors)
r = sqrt(eig2$values)
sigma = r*diag(length(r))
stdev = r / sqrt(max(1, nrow(A) - 1))
x = A %*% V
res = list(sdev = stdev, rotation = V, x = x)
res
}
#Extract PCAs
pca_data = pca(x.sample)
screeplot(pca_data,main = deparse(substitute(pca_data)))
diff_index = xts(pca_data$x[,1:5], order.by = dates[1:273])
diff_index
pca = function(A){
ATA  = t(A)%*%A
AAT  = A%*%t(A)
eig1 = eigen(ATA)
eig2 = eigen(AAT)
V    = as.matrix(eig1$vectors)
U    = as.matrix(eig2$vectors)
dimnames(V) = list(colnames(A),paste0("PC",seq_len(ncol(V))))
stdev = sqrt(eig2$values) / sqrt(max(1, nrow(A) - 1))
x     = A %*% V
res   = list(sdev = stdev, rotation = V, x = x)
res
}
pca_data = pca(x.sample)
screeplot(pca_data,main = deparse(substitute(pca_data)))
diff_index = xts(pca_data$x[,1:5], order.by = dates[1:273])
library(formatR)
tidy_source(source = paste(getwd(),"/Qpca/Qpca.r"), file = paste(getwd(),"/Qpca/Qpca.r"))
tidy_source(source = paste(getwd(),"/Qpca/Qpca.r"), file = paste(getwd(),"/Qpca/Qpca.r"))
# needed only for package installation or update
install.packages("yaml")
library(devtools)
devtools::install_github("lborke/yamldebugger")
# load the package every time you want to use 'yamldebugger'
library(yamldebugger)
"data" %in% allKeywords
allKeywords
d_init = yaml.debugger.init(getwd(), show_keywords = FALSE)
qnames = yaml.debugger.get.qnames(d_init$RootPath)
d_results = yaml.debugger.run(qnames, d_init)
d_results$possible_pictures
OverView = yaml.debugger.summary(qnames, d_results, summaryType = "mini")
tidy_source(source = paste(getwd(),"/Qpca/Qpca.r"), file = paste(getwd(),"/Qpca/Qpca.r"))
tidy_source(source = "C:/Users/Ellet/OneDrive/Winfo Studium/WS1718/Statistical Programming Languages/repo/statproglang/Qpca/Qpca.r", file = "C:/Users/Ellet/OneDrive/Winfo Studium/WS1718/Statistical Programming Languages/repo/statproglang/Qpca/Qpca.r")
d_results = yaml.debugger.run(qnames, d_init)
OverView = yaml.debugger.summary(qnames, d_results, summaryType = "mini")
screeplot(pca_data, main = deparse(substitute(pca_data)),type = "l")
pca = function(x) {
#compute eigen values to create orthogonal matrices U and V
xTx  = t(x) %*% x
xxT  = x %*% t(x)
eig1 = eigen(xTx)
eig2 = eigen(xxT)
V    = as.matrix(eig1$vectors)
U    = as.matrix(eig2$vectors)
dimnames(V) = list(colnames(x), paste0("PC", seq_len(ncol(V))))
#compute sigma values and normalize
stdev = sqrt(eig2$values)/sqrt(max(1, nrow(x) - 1))
#compute USigma
x     = x %*% V
res   = list(sdev = stdev, rotation = V, x = x)
res
}
pca_data = pca(x.sample)
screeplot(pca_data, main = deparse(substitute(pca_data)),type = "l")
