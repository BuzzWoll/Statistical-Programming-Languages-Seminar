yp=predict(fit,newdata=df)
df$yr=df$yr - alpha*yp
YP = YP + alpha*yp
}
plot(df$x,df$y)
lines(df$x,YP)
#cool explanation here:
#https://www.r-bloggers.com/an-attempt-to-understand-boosting-algorithms/
library(rpart)
#df = as.data.frame(cbind(x,y))
#names(df) <- c("x","z","y")
alpha=.1
fit=rpart(y~.,data=df,control = list(maxdepth = 1))
yp=predict(fit)
df$yr=df$y - alpha*yp
YP = alpha*yp
for(t in 1:400){
fit=rpart(yr~x,data=df,control = list(maxdepth = 1))
yp=predict(fit,newdata=df)
df$yr=df$yr - alpha*yp
YP = YP + alpha*yp
}
plot(df$x,df$y)
lines(df$x,YP)
#cool explanation here:
#https://www.r-bloggers.com/an-attempt-to-understand-boosting-algorithms/
library(rpart)
#df = as.data.frame(cbind(x,y))
#names(df) <- c("x","z","y")
alpha=.1
fit=rpart(y~.,data=df,control = list(maxdepth = 2))
yp=predict(fit)
df$yr=df$y - alpha*yp
YP = alpha*yp
for(t in 1:400){
fit=rpart(yr~x,data=df,control = list(maxdepth = 2))
yp=predict(fit,newdata=df)
df$yr=df$yr - alpha*yp
YP = YP + alpha*yp
}
plot(df$x,df$y)
lines(df$x,YP)
#cool explanation here:
#https://www.r-bloggers.com/an-attempt-to-understand-boosting-algorithms/
library(rpart)
#df = as.data.frame(cbind(x,y))
#names(df) <- c("x","z","y")
alpha=.05
fit=rpart(y~.,data=df,control = list(maxdepth = 2))
yp=predict(fit)
df$yr=df$y - alpha*yp
YP = alpha*yp
for(t in 1:400){
fit=rpart(yr~x,data=df,control = list(maxdepth = 2))
yp=predict(fit,newdata=df)
df$yr=df$yr - alpha*yp
YP = YP + alpha*yp
}
plot(df$x,df$y)
lines(df$x,YP)
# needed only for package installation or update
install.packages("yaml")
library(devtools)
devtools::install_github("lborke/yamldebugger")
# load the package every time you want to use 'yamldebugger'
library(yamldebugger)
"data" %in% allKeywords
allKeywords
d_init = yaml.debugger.init(getwd(), show_keywords = FALSE)
qnames = yaml.debugger.get.qnames(d_init$RootPath)
d_results = yaml.debugger.run(qnames, d_init)
d_results$possible_pictures
OverView = yaml.debugger.summary(qnames, d_results, summaryType = "mini")
# needed only for package installation or update
#install.packages("yaml")
library(devtools)
#devtools::install_github("lborke/yamldebugger")
# load the package every time you want to use 'yamldebugger'
library(yamldebugger)
#allKeywords
d_init = yaml.debugger.init(getwd(), show_keywords = FALSE)
qnames = yaml.debugger.get.qnames(d_init$RootPath)
d_results = yaml.debugger.run(qnames, d_init)
d_results$possible_pictures
OverView = yaml.debugger.summary(qnames, d_results, summaryType = "mini")
# needed only for package installation or update
#install.packages("yaml")
library(devtools)
#devtools::install_github("lborke/yamldebugger")
# load the package every time you want to use 'yamldebugger'
library(yamldebugger)
#allKeywords
d_init = yaml.debugger.init(getwd(), show_keywords = FALSE)
qnames = yaml.debugger.get.qnames(d_init$RootPath)
d_results = yaml.debugger.run(qnames, d_init)
d_results$possible_pictures
OverView = yaml.debugger.summary(qnames, d_results, summaryType = "mini")
# needed only for package installation or update
#install.packages("yaml")
library(devtools)
#devtools::install_github("lborke/yamldebugger")
# load the package every time you want to use 'yamldebugger'
library(yamldebugger)
#allKeywords
d_init = yaml.debugger.init(getwd(), show_keywords = FALSE)
qnames = yaml.debugger.get.qnames(d_init$RootPath)
d_results = yaml.debugger.run(qnames, d_init)
d_results$possible_pictures
OverView = yaml.debugger.summary(qnames, d_results, summaryType = "mini")
knitr::opts_chunk$set(echo = TRUE)
5-5/2
5-5/0
length()
length(c())
subtractMean <- function(x){
if(length(x)==0){
x
}else{
x - (x / length(x))
}
}
subtractMean(c(1,2,3,4,5))
subtractMean <- function(x){
if(length(x)==0){
x
}else{
x - mean(x))
subtractMean <- function(x){
if(length(x)==0){
x
}else{
x - mean(x)
}
}
subtractMean(c(1,2,3,4,5))
subtractMean <- function(x){
if(length(x)==0){
x
}else{
x - sum(x)/length(x)
}
}
subtractMean(c(1,2,3,4,5))
a = matrix(c(1,2,3,4,5,6),nrow = 3,ncol = 2)
scaleCustom <- function(x,center = T,scale = T){
if(center == T){
apply(x,2,subtractMean)
}
}
scaleCustom(a)
scale()
subtractMean <- function(x){
if(length(x)==0){
x
}else{
x - sum(x)/length(x)
}
}
a = matrix(c(1,2,3,4,6,8),nrow = 3,ncol = 2)
scaleCustom <- function(x,center = T,scale = T){
if(center == T){
apply(x,2,subtractMean)
}
}
scaleCustom(a)
subtractMean <- function(x){
if(length(x)==0){
x
}else{
x - sum(x)/length(x)
}
}
a = matrix(c(1,2,3,4,6.5,8),nrow = 3,ncol = 2)
scaleCustom <- function(x,center = T,scale = T){
if(center == T){
apply(x,2,subtractMean)
}
}
scaleCustom(a)
rmse = function(x){
sqrt(sum(x^2)/length(x))
}
sd(c(1,2))
std(c(1,2))
std = function(x){
sqrt(mean(abs(x - mean(x))^2))
}
std(c(1,2))
std(1:2)
sd(1:2)
std = function(x){
sqrt(abs(x - mean(x))^2/((length(x)-1)))
}
std(1:2)
std = function(x){
sqrt(sum(x - mean(x))^2/((length(x)-1)))
}
sd(1:2)
std(1:2)
std = function(x){
sqrt( sum( (x - mean(x) )^2) / ( (length(x)-1) ) )
}
sd(1:2)
std(1:2)
subtractMean = function(x){
x - mean(x)
}
std = function(x){
sqrt( sum( (x - mean(x) )^2) / ( (length(x)-1) ) )
}
rms = function(x){
sqrt(sum(x^2)/(length(x)-1))
}
a = matrix(c(1,2,3,4,6.5,8),nrow = 3,ncol = 2)
#custom scale function based on the functionality of R's base package scale function
scaleCustom = function(x,center = T,scale = T){
if(center == T){
x = apply(x,2,subtractMean)
if(scale == T){
x / std(x)
}else{
x
}
}else{
if(scale == T){
x / rms(x)
}else{
x
}
}
}
scaleCustom(a)
scale(a)
subtractMean = function(x){
x - mean(x)
}
std = function(x){
sqrt( sum( (x - mean(x) )^2) / ( (length(x)-1) ) )
}
rms = function(x){
sqrt(sum(x^2)/(length(x)-1))
}
a = matrix(c(1,2,3,4,6.5,8),nrow = 3,ncol = 2)
#custom scale function based on the functionality of R's base package scale function
scaleCustom = function(x,center = T,scale = T){
if(center == T){
x = sapply(x,subtractMean)
if(scale == T){
x / std(x)
}else{
x
}
}else{
if(scale == T){
x / rms(x)
}else{
x
}
}
}
scaleCustom(a)
subtractMean = function(x){
x - mean(x)
}
std = function(x){
sqrt( sum( (x - mean(x) )^2) / ( (length(x)-1) ) )
}
rms = function(x){
sqrt(sum(x^2)/(length(x)-1))
}
a = matrix(c(1,2,3,4,6.5,8),nrow = 3,ncol = 2)
#custom scale function based on the functionality of R's base package scale function
scaleCustom = function(x,center = T,scale = T){
if(center == T){
x = apply(x,2,subtractMean)
if(scale == T){
x / std(x)
}else{
x
}
}else{
if(scale == T){
x / rms(x)
}else{
x
}
}
}
scaleCustom(a)
sapply(a,scale)
apply(a,2,scale)
scaleCustom(a)
apply(a,scale)
apply(a,2,scale)
apply(a,2,scaleCustom)
subtractMean = function(x){
x - mean(x)
}
std = function(x){
sqrt( sum( (x - mean(x) )^2) / ( (length(x)-1) ) )
}
rms = function(x){
sqrt(sum(x^2)/(length(x)-1))
}
a = matrix(c(1,2,3,4,6.5,8),nrow = 3,ncol = 2)
#custom scale function based on the functionality of R's base package scale function
scaleCustom = function(x,center = T,scale = T){
print(x)
if(center == T){
x = apply(x,2,subtractMean)
if(scale == T){
x / std(x)
}else{
x
}
}else{
if(scale == T){
x / rms(x)
}else{
x
}
}
}
apply(a,2,scaleCustom)
apply(a,2,scale)
subtractMean = function(x){
x - mean(x)
}
std = function(x){
sqrt( sum( (x - mean(x) )^2) / ( (length(x)-1) ) )
}
rms = function(x){
sqrt(sum(x^2)/(length(x)-1))
}
a = matrix(c(1,2,3,4,6.5,8),nrow = 3,ncol = 2)
#custom scale function based on the functionality of R's base package scale function
scaleCustom = function(x,center = T,scale = T){
print(x)
if(center == T){
x = subtractMean(x)
if(scale == T){
x / std(x)
}else{
x
}
}else{
if(scale == T){
x / rms(x)
}else{
x
}
}
}
apply(a,2,scaleCustom)
apply(a,2,scale)
subtractMean = function(x){
x - mean(x)
}
std = function(x){
sqrt( sum( (x - mean(x) )^2) / ( (length(x)-1) ) )
}
rms = function(x){
sqrt(sum(x^2)/(length(x)-1))
}
a = matrix(c(1,2,3,4,6.5,8),nrow = 3,ncol = 2)
#custom scale function based on the functionality of R's base package scale function
scaleCustom = function(x,center = T,scale = T){
if(center == T){
x = subtractMean(x)
if(scale == T){
x / std(x)
}else{
x
}
}else{
if(scale == T){
x / rms(x)
}else{
x
}
}
}
apply(a,2,scaleCustom)
apply(a,2,scale)
scaleCustom(a)
scale(a)
sapply(a,scale)
sapply(a,scaleCustom)
knitr::opts_chunk$set(echo = TRUE)
print(scaledtrain)
sapply(trainprepared,scale)
#simple regressor
#decision tree
#find split with lowest possible standard deviation
std <- function(x){
sqrt(mean(abs(x - mean(x))^2))
}
decisionTree <- function(x,y,idxs=NA,min_leaf=2){
if(any(is.na(idxs))){
idxs <- 1:length(y)
}
x <- as.matrix(x)
y <- as.matrix(y)
#n = number of rows of data
#c = number of cols
#val = prediction for all values in tree (mean of all indices)
#score = how effective was the split
tree <- list(x = x, y=y,idxs=idxs,min_leaf=min_leaf,lhs = NULL, rhs = NULL,var_idx = NA, split = NA, n = length(idxs),c = dim(x)[2],val = mean(y[idxs]),score = Inf)
findSplit(tree)
}
#which variable should we split on and on what level?
findSplit <- function(tree){
#for every column, check if we can find a better split (with 1 dataset we will neven)
for (i in 1:tree$c){
tree <- findBetterSplit(tree,i)
}
if(tree$score==Inf){
NULL
}else{
x <- tree$x[tree$idxs,tree$var_idx]
lhs = which(!(x<=tree$split)==0)
rhs = which(!(x>tree$split)==0)
tree$lhs = decisionTree(tree$x,tree$y,tree$idxs[lhs])
tree$rhs = decisionTree(tree$x,tree$y,tree$idxs[rhs])
tree
}
}
findBetterSplit <- function(tree,var_idx){
#define values at the node (based on the indices passed down from above)
x = tree$x[tree$idxs,var_idx]
y = tree$y[tree$idxs]
count = tree$n - 1
#find best split by going through every row (this is slow because some values may be repeated)
if(count>0){
for (i in 1:count){
lhs = x<=x[i]
rhs = x>x[i]
if (sum(rhs)==0){
next
}
lhs_std = std(y[lhs])
rhs_std = std(y[rhs])
curr_score = lhs_std*sum(lhs) + rhs_std*sum(rhs)
if(curr_score<tree$score){
tree$var_idx = var_idx
tree$split = x[i]
tree$score = curr_score
}
}
}
tree
}
#implementing gradient boosting from scratch
#generating data for test purposes
x = 1:50
y1 = runif(10,max= 15,min=10)
y2 = runif(10,max=25,min=20)
y3 = runif(10,max=5,min=0)
y4 = runif(10,max=35,min=30)
y5 = runif(10,max=17,min=13)
y=c(y1,y2,y3,y4,y5)
y <- scale(y,scale = F)
z1 = runif(10,max=14,min=9)
z2 = runif(10,max=24,min=19)
z3 = runif(10,max=6,min=1)
z4 = runif(10,max=37,min=32)
z5 = runif(10,max=15,min=11)
z = c(z1,z2,z3,z4,z5)
x = cbind(x,z)
#initialization
#x <- as.matrix(df$x)
#y <- as.matrix(df$y)
xi = x
yi = y
alpha = .5
ei = 0
n=length(yi)
predf = 0
for (i in 1:20){
tree <- decisionTree(xi,yi)
#tree <- findBetterSplit(tree,1)
r = which(xi == tree$split, arr.ind = T)
column = r[,"col"]
left_idx = which(xi[,column] <= tree$split)
right_idx = which(xi[,column] > tree$split)
predi = numeric(n)
predi[left_idx]<-mean(yi[left_idx])
predi[right_idx]<-mean(yi[right_idx])
predf = predf + predi
ei = y-predf
yi = ei * alpha
#plot(x[,1],y)
#lines(x[,1],predf)
}
plot(x[,1],y)
lines(x[,1],predf)
print(predf)
apply(trainprepared,2,scaleCustom)
apply(trainprepared[,-1],2,scaleCustom)
any(apply(trainprepared[,-1],2,scaleCustom)==sapply(trainprepared[,-1],scale)==FALSE)
any(apply(trainprepared[,-1],2,scaleCustom)==sapply(trainprepared[,-1],scale))
apply(trainprepared[,-1],2,scaleCustom)==sapply(trainprepared[,-1],scale)
print(head(apply(trainprepared[,-1],2,scaleCustom)))
print(head(sapply(trainprepared[,-1],scale)))
source('C:/Users/Ellet/OneDrive/Winfo Studium/WS1718/Statistical Programming Languages/repo/statproglang/Qprepare/Qprepare.r', echo=TRUE)
setwd("C:/Users/Ellet/OneDrive/Winfo Studium/WS1718/Statistical Programming Languages/repo/statproglang/Qprepare")
source('C:/Users/Ellet/OneDrive/Winfo Studium/WS1718/Statistical Programming Languages/repo/statproglang/Qprepare/Qprepare.r', echo=TRUE)
scaledtrain2 = trainprepared
scaledtrain2[, -1] = sapply(trainprepared[,-1],scale)
head(scaledtrain[,1:3])
head(scaledtrain2[,1:3])
source('C:/Users/Ellet/OneDrive/Winfo Studium/WS1718/Statistical Programming Languages/repo/statproglang/Qprepare/Qprepare.r', echo=TRUE)
